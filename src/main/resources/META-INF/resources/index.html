<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>CodeMirror 5 in Quarkus</title>

    <link rel="icon" type="image/png" href="favicon.png" />

    <!-- CodeMirror 5 CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
    <!-- Optional theme (Monokai) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/dracula.min.css" />
    <link rel="stylesheet" href="styles.css" />
    <link rel="stylesheet" href="editor_highlighting.css" />
</head>
<body>

<h1>Simple CodeMirror 5 Editor</h1>

<div id="editor-wrapper">
    <textarea id="editor"># Big headline
## Smaller headline
### type 3 headline
#### type 4 headline
normal line
! This is important
? A question
/ Done task
// Comment
> Output line
/- Struck through
//- Struck-through comment

</textarea>
</div>

<!-- CodeMirror core JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<!-- Keymaps (Sublime, Vim, etc.) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/keymap/sublime.min.js"></script>

<script>
    const editor = CodeMirror.fromTextArea(document.getElementById('editor'), {
      mode: 'markdown',
      theme: 'dracula',
      lineNumbers: true,
      lineWrapping: true,
      keyMap: 'sublime',
      extraKeys: {
        'Ctrl-S': function(cm) {
          const content = cm.getValue();
          const cursor = cm.getCursor();
          alert('Ctrl+S pressed!\n\nContent:\n' + content + '\n\nCursor at line ' + cursor.line);
        },
        'Ctrl-D': function(cm) {
          const line = cm.getCursor().line;
          cm.replaceRange("", { line, ch: 0 }, { line: line + 1, ch: 0 });
        },
        'Ctrl-Alt-D': function(cm) {
          toggleLinePrefix(cm, '/ ');
          return true; // Prevent default behavior
        },
        'Ctrl-Alt-C': function(cm) {
          toggleLinePrefix(cm, '// ');
          return true; // Prevent default behavior
        },
        'Ctrl-Alt-I': function(cm) {
          toggleLinePrefix(cm, '! ');
          return true; // Prevent default behavior
        },
        'Ctrl-Alt-Q': function(cm) {
          toggleLinePrefix(cm, '? ');
          return true; // Prevent default behavior
        },
        'Ctrl-Alt-S': function(cm) {
          toggleLinePrefix(cm, '/- ');
          return true; // Prevent default behavior
        },
        'Ctrl-Alt-1': function(cm) {
          toggleLinePrefix(cm, '# ');
          return true; // Prevent default behavior
        },
        'Ctrl-Alt-2': function(cm) {
          toggleLinePrefix(cm, '## ');
          return true; // Prevent default behavior
        },
        'Ctrl-Alt-3': function(cm) {
          toggleLinePrefix(cm, '### ');
          return true; // Prevent default behavior
        },
        'Ctrl-Alt-4': function(cm) {
          toggleLinePrefix(cm, '#### ');
          return true; // Prevent default behavior
        },
      }
    });

    function addHighlighting() {
      const totalLines = editor.lineCount();

      for (let i = 0; i < totalLines; i++) {
        const line = editor.getLine(i);
        const trimmed = line.trim();

        // Remove all previously applied custom line classes
        editor.removeLineClass(i, "wrap", null);

        // Headings
        if (/^#### /.test(line)) {
          editor.addLineClass(i, "wrap", "line-headline-4");
        } else if (/^### /.test(line)) {
          editor.addLineClass(i, "wrap", "line-headline-3");
        } else if (/^## /.test(line)) {
          editor.addLineClass(i, "wrap", "line-headline-2");
        } else if (/^# /.test(line)) {
          editor.addLineClass(i, "wrap", "line-headline-1");
        }

        // Other prefixes (ignore leading whitespace)
        else if (/^\s*!/.test(line)) {
          editor.addLineClass(i, "wrap", "line-important");
        } else if (/^\s*\?/.test(line)) {
          editor.addLineClass(i, "wrap", "line-question");
        } else if (/^\s*\/\/\-/.test(line)) {
          editor.addLineClass(i, "wrap", "line-struck-comment");
        } else if (/^\s*\/\/ /.test(line)) {
          editor.addLineClass(i, "wrap", "line-comment");
        } else if (/^\s*\/ /.test(line)) {
          editor.addLineClass(i, "wrap", "line-done");
        } else if (/^\s*>/.test(line)) {
          editor.addLineClass(i, "wrap", "line-result");
        } else if (/^\s*\/-/.test(line)) {
          editor.addLineClass(i, "wrap", "line-struck");
        }
      }
    }

    function toggleLinePrefix(cm, prefix) {
      const selections = cm.listSelections();

      cm.operation(() => {
        selections.forEach(sel => {
          const fromLine = sel.from().line;
          const toLine = sel.to().line;

          const allPrefixed = [];
          for (let i = fromLine; i <= toLine; i++) {
            const lineContent = cm.getLine(i);
            allPrefixed.push(lineContent.trimStart().startsWith(prefix));
          }

          const shouldRemove = allPrefixed.every(Boolean);

          for (let i = fromLine; i <= toLine; i++) {
            const lineContent = cm.getLine(i);
            const leadingSpaces = lineContent.match(/^\s*/)[0];

            if (shouldRemove) {
              if (lineContent.trimStart().startsWith(prefix)) {
                const updated = lineContent.replace(new RegExp(`^\\s*${escapeRegex(prefix)}`), leadingSpaces);
                cm.replaceRange(updated, { line: i, ch: 0 }, { line: i, ch: lineContent.length });
              }
            } else {
              cm.replaceRange(leadingSpaces + prefix + lineContent.trimStart(), { line: i, ch: 0 }, { line: i, ch: lineContent.length });
            }
          }
        });
      });

      event.preventDefault();
    }

    // Utility to escape regex special characters
    function escapeRegex(s) {
      return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    // Run on load
    addHighlighting();

    // Run on change
    editor.on("change", addHighlighting);
</script>

</body>
</html>
